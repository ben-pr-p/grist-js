// This file is auto-generated by @hey-api/openapi-ts

export type Org = {
  id: number;
  name: string;
  domain: string | null;
  owner: User | null;
  access: Access;
  createdAt: string;
  updatedAt: string;
};

export type Orgs = Array<Org>;

export type Webhooks = Array<Webhook>;

export type Webhook = {
  id?: string;
  fields?: WebhookFields;
  usage?: WebhookUsage;
};

export type WebhookFields = WebhookPartialFields & WebhookRequiredFields;

export type WebhookRequiredFields = {
  unsubscribeKey: string;
};

export type WebhookPartialFields = {
  name?: string | null;
  memo?: string | null;
  url?: string;
  enabled?: boolean;
  eventTypes?: Array<string>;
  isReadyColumn?: string | null;
  tableId?: string;
};

export type WebhookUsage = {
  numWaiting: number;
  status: string;
  updatedTime?: number | null;
  lastSuccessTime?: number | null;
  lastFailureTime?: number | null;
  lastErrorMessage?: string | null;
  lastHttpStatus?: number | null;
  lastEventBatch?: WebhookBatchStatus;
} | null;

export type WebhookBatchStatus = {
  size: number;
  attempts: number;
  errorMessage?: string | null;
  httpStatus?: number;
  status: string;
} | null;

export type WebhookId = {
  /**
   * Webhook identifier
   */
  id: string;
};

export type WebhookRequiredProperties = {
  size: number;
};

export type Workspace = {
  id: number;
  name: string;
  access: Access;
};

export type Doc = {
  id: string;
  name: string;
  access: Access;
  isPinned: boolean;
  urlId: string | null;
};

export type WorkspaceWithDocs = Workspace & {
  docs: Array<Doc>;
};

export type WorkspaceWithDocsAndDomain = WorkspaceWithDocs & {
  orgDomain?: string;
};

export type WorkspaceWithOrg = Workspace & {
  org: Org;
};

export type WorkspaceWithDocsAndOrg = WorkspaceWithDocs & WorkspaceWithOrg;

export type DocWithWorkspace = Doc & {
  workspace: WorkspaceWithOrg;
};

export type User = {
  id: number;
  name: string;
  picture: string | null;
};

export type Access = "owners" | "editors" | "viewers";

export type Data = {
  id: Array<number>;
  [key: string]: (Array<number> | number) | undefined;
};

export type DataWithoutId = {
  [key: string]: Array<{
    [key: string]: unknown;
  }>;
};

export type RecordsList = {
  records: Array<{
    id: number;
    /**
     * A JSON object mapping column names to [cell values](https://support.getgrist.com/code/interfaces/grist_plugin_api.rowrecord/#cellvalues).
     */
    fields: {
      [key: string]: unknown;
    };
  }>;
};

export type RecordsWithoutId = {
  records: Array<{
    /**
     * A JSON object mapping column names to [cell values](https://support.getgrist.com/code/interfaces/grist_plugin_api.rowrecord/#cellvalues).
     */
    fields: {
      [key: string]: unknown;
    };
  }>;
};

export type RecordsWithoutFields = {
  records: Array<{
    id: number;
  }>;
};

export type RecordsWithRequire = {
  records: Array<{
    /**
     * keys are column identifiers, and values are [cell values](https://support.getgrist.com/code/interfaces/grist_plugin_api.rowrecord/#cellvalues) we want to have in those columns (either by matching with an existing record, or creating a new record)
     *
     */
    require: {
      [key: string]: unknown;
    };
    /**
     * keys are column identifiers, and values are [cell values](https://support.getgrist.com/code/interfaces/grist_plugin_api.rowrecord/#cellvalues) to place in those columns (either overwriting values in an existing record, or in a new record)
     *
     */
    fields?: {
      [key: string]: unknown;
    };
  }>;
};

export type TablesList = {
  tables: Array<{
    id: string;
    fields: {
      [key: string]: unknown;
    };
  }>;
};

export type TablesWithoutFields = {
  tables: Array<{
    id: string;
  }>;
};

export type CreateTables = {
  tables: Array<{
    id?: string;
    columns: Array<{
      id?: string;
      fields?: {
        [key: string]: unknown;
      };
    }>;
  }>;
};

export type ColumnsList = {
  columns?: Array<{
    id?: string;
    fields?: GetFields;
  }>;
};

export type CreateColumns = {
  columns: Array<{
    /**
     * Column identifier
     */
    id?: string;
    fields?: CreateFields;
  }>;
};

export type UpdateColumns = {
  columns: Array<{
    /**
     * Column identifier
     */
    id: string;
    fields: CreateFields & {
      /**
       * Set it to the new column ID when you want to change it.
       */
      colId?: string;
    };
  }>;
};

export type ColumnsWithoutFields = {
  columns: Array<{
    id: string;
  }>;
};

export type Fields = {
  /**
   * Column type, by default Any. Ref, RefList and DateTime types requires a postfix, e.g. <code>DateTime:America/New_York</code>, <code>Ref:Users</code>
   */
  type?: string;
  /**
   * Column label.
   */
  label?: string;
  /**
   * A python formula, e.g.: <code>$A + Table1.lookupOne(B=$B)</code>
   */
  formula?: string;
  /**
   * Use "true" to indicate that the column is a formula column. Use "false" for trigger formula column.
   */
  isFormula?: boolean;
  /**
   * A JSON object with widget options, e.g.: <code>{"choices": ["cat", "dog"], "alignment": "right"}</code>
   */
  widgetOptions?: string;
  /**
   * Use "true" to indicate that the column label should not be used as the column identifier. Use "false" to use the label as the identifier.
   */
  untieColIdFromLabel?: boolean;
  /**
   * A number indicating when the column should be recalculated. <ol start='0'><li>On new records or when any field in recalcDeps changes, it's a 'data-cleaning'.</li><li>Never.</li><li>Calculate on new records and on manual updates to any data field.</li></ol>
   */
  recalcWhen?: number;
  /**
   * For Ref and RefList columns, the colRef of a column to display
   */
  visibleCol?: number;
};

export type CreateFields = Fields & {
  /**
   * An encoded array of column identifiers (colRefs) that this column depends on. If any of these columns change, the column will be recalculated. E.g.: <code>[2, 3]</code>
   */
  recalcDeps?: string;
};

export type GetFields = Fields & {
  /**
   * An array of column identifiers (colRefs) that this column depends on, prefixed with "L" constant. If any of these columns change, the column will be recalculated. E.g.: <code>["L", 2, 3]</code>
   */
  recalcDeps?: Array<number>;
  /**
   * Column reference, e.g.: <code>2</code>
   */
  colRef?: number;
};

export type RowIds = Array<number>;

export type DocParameters = {
  name?: string;
  isPinned?: boolean;
};

export type WorkspaceParameters = {
  name?: string;
};

export type OrgParameters = {
  name?: string;
};

export type OrgAccessRead = {
  users: Array<{
    id: number;
    name: string;
    email?: string;
    access?: Access;
  }>;
};

export type OrgAccessWrite = {
  users: {
    [key: string]: "owners" | "editors" | "viewers" | "members";
  };
};

export type WorkspaceAccessRead = {
  maxInheritedRole: Access;
  users: Array<{
    id: number;
    name: string;
    email?: string;
    access?: Access;
    parentAccess?: Access;
  }>;
};

export type WorkspaceAccessWrite = {
  maxInheritedRole?: Access;
  users?: {
    [key: string]: "owners" | "editors" | "viewers" | "members";
  };
};

export type DocAccessWrite = WorkspaceAccessWrite;

export type DocAccessRead = WorkspaceAccessRead;

export type AttachmentUpload = {
  upload?: Array<Blob | File>;
};

/**
 * An integer ID
 */
export type AttachmentId = number;

export type AttachmentMetadata = {
  fileName?: string;
  fileSize?: number;
  timeUploaded?: string;
};

export type AttachmentMetadataList = {
  records: Array<{
    id: number;
    fields: AttachmentMetadata;
  }>;
};

export type SqlResultSet = {
  /**
   * A copy of the SQL statement.
   */
  statement: string;
  records: Array<{
    fields: {
      [key: string]: unknown;
    };
  }>;
};

export type TableSchemaResult = {
  /**
   * The ID (technical name) of the table
   */
  name: string;
  /**
   * The human readable name of the table
   */
  title: string;
  /**
   * The URL to download the CSV
   */
  path?: string;
  format?: "csv";
  mediatype?: "text/csv";
  encoding?: "utf-8";
  /**
   * The CSV dialect descriptor.
   */
  dialect?: {
    /**
     * A number to indicate the schema version of CSV Dialect. Version 1.0 was named CSV Dialect Description Format and used different field names.
     */
    csvddfVersion?: number;
    /**
     * A character sequence to use as the field separator.
     */
    delimiter: string;
    /**
     * Specifies the handling of quotes inside fields.
     */
    doubleQuote: boolean;
    /**
     * Specifies the character sequence that must be used to terminate rows.
     */
    lineTerminator?: string;
    /**
     * Specifies the null sequence, for example, `\N`.
     */
    nullSequence?: string;
    /**
     * Specifies a one-character string to use as the quoting character.
     */
    quoteChar?: string;
    /**
     * Specifies a one-character string to use as the escape character.
     */
    escapeChar?: string;
    /**
     * Specifies the interpretation of whitespace immediately following a delimiter. If false, whitespace immediately after a delimiter should be treated as part of the subsequent field.
     */
    skipInitialSpace?: boolean;
    /**
     * Specifies if the file includes a header row, always as the first row in the file.
     */
    header?: boolean;
    /**
     * Specifies that any row beginning with this one-character string, without preceeding whitespace, causes the entire line to be ignored.
     */
    commentChar?: string;
    /**
     * Specifies if the case of headers is meaningful.
     */
    caseSensitiveHeader?: boolean;
  };
  /**
   * A Table Schema for this resource, compliant with the [Table Schema](/tableschema/) specification.
   */
  schema: {
    /**
     * An `array` of Table Schema Field objects.
     */
    fields: Array<
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `string`.
           */
          type?: "string";
          /**
           * The format keyword options for `string` are `default`, `email`, `uri`, `binary`, and `uuid`.
           */
          format?: "default" | "email" | "uri" | "binary" | "uuid";
          /**
           * The following constraints are supported for `string` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            /**
             * A regular expression pattern to test each value of the property against, where a truthy response indicates validity.
             */
            pattern?: string;
            enum?: Array<string>;
            /**
             * An integer that specifies the minimum length of a value.
             */
            minLength?: number;
            /**
             * An integer that specifies the maximum length of a value.
             */
            maxLength?: number;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `number`.
           */
          type: "number";
          /**
           * There are no format keyword options for `number`: only `default` is allowed.
           */
          format?: "default";
          /**
           * a boolean field with a default of `true`. If `true` the physical contents of this field must follow the formatting constraints already set out. If `false` the contents of this field may contain leading and/or trailing non-numeric characters (which implementors MUST therefore strip). The purpose of `bareNumber` is to allow publishers to publish numeric data that contains trailing characters such as percentages e.g. `95%` or leading characters such as currencies e.g. `€95` or `EUR 95`. Note that it is entirely up to implementors what, if anything, they do with stripped text.
           */
          bareNumber?: boolean;
          /**
           * A string whose value is used to represent a decimal point within the number. The default value is `.`.
           */
          decimalChar?: string;
          /**
           * A string whose value is used to group digits within the number. The default value is `null`. A common value is `,` e.g. '100,000'.
           */
          groupChar?: string;
          /**
           * The following constraints are supported for `number` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?: Array<string> | Array<number>;
            minimum?: string | number;
            maximum?: string | number;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `integer`.
           */
          type: "integer";
          /**
           * There are no format keyword options for `integer`: only `default` is allowed.
           */
          format?: "default";
          /**
           * a boolean field with a default of `true`. If `true` the physical contents of this field must follow the formatting constraints already set out. If `false` the contents of this field may contain leading and/or trailing non-numeric characters (which implementors MUST therefore strip). The purpose of `bareNumber` is to allow publishers to publish numeric data that contains trailing characters such as percentages e.g. `95%` or leading characters such as currencies e.g. `€95` or `EUR 95`. Note that it is entirely up to implementors what, if anything, they do with stripped text.
           */
          bareNumber?: boolean;
          /**
           * The following constraints are supported for `integer` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?: Array<string> | Array<number>;
            minimum?: string | number;
            maximum?: string | number;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `date`.
           */
          type: "date";
          /**
           * The format keyword options for `date` are `default`, `any`, and `{PATTERN}`.
           */
          format?: unknown;
          /**
           * The following constraints are supported for `date` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?: Array<string>;
            minimum?: string;
            maximum?: string;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `time`.
           */
          type: "time";
          /**
           * The format keyword options for `time` are `default`, `any`, and `{PATTERN}`.
           */
          format?: unknown;
          /**
           * The following constraints are supported for `time` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?: Array<string>;
            minimum?: string;
            maximum?: string;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `datetime`.
           */
          type: "datetime";
          /**
           * The format keyword options for `datetime` are `default`, `any`, and `{PATTERN}`.
           */
          format?: unknown;
          /**
           * The following constraints are supported for `datetime` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?: Array<string>;
            minimum?: string;
            maximum?: string;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `year`.
           */
          type: "year";
          /**
           * There are no format keyword options for `year`: only `default` is allowed.
           */
          format?: "default";
          /**
           * The following constraints are supported for `year` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?: Array<string> | Array<number>;
            minimum?: string | number;
            maximum?: string | number;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `yearmonth`.
           */
          type: "yearmonth";
          /**
           * There are no format keyword options for `yearmonth`: only `default` is allowed.
           */
          format?: "default";
          /**
           * The following constraints are supported for `yearmonth` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?: Array<string>;
            minimum?: string;
            maximum?: string;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `boolean`.
           */
          type: "boolean";
          /**
           * There are no format keyword options for `boolean`: only `default` is allowed.
           */
          format?: "default";
          trueValues?: Array<string>;
          falseValues?: Array<string>;
          /**
           * The following constraints are supported for `boolean` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            enum?: Array<boolean>;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `object`.
           */
          type: "object";
          /**
           * There are no format keyword options for `object`: only `default` is allowed.
           */
          format?: "default";
          /**
           * The following constraints apply for `object` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?:
              | Array<string>
              | Array<{
                  [key: string]: unknown;
                }>;
            /**
             * An integer that specifies the minimum length of a value.
             */
            minLength?: number;
            /**
             * An integer that specifies the maximum length of a value.
             */
            maxLength?: number;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `geopoint`.
           */
          type: "geopoint";
          /**
           * The format keyword options for `geopoint` are `default`,`array`, and `object`.
           */
          format?: "default" | "array" | "object";
          /**
           * The following constraints are supported for `geopoint` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?:
              | Array<string>
              | Array<unknown[]>
              | Array<{
                  [key: string]: unknown;
                }>;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `geojson`.
           */
          type: "geojson";
          /**
           * The format keyword options for `geojson` are `default` and `topojson`.
           */
          format?: "default" | "topojson";
          /**
           * The following constraints are supported for `geojson` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?:
              | Array<string>
              | Array<{
                  [key: string]: unknown;
                }>;
            /**
             * An integer that specifies the minimum length of a value.
             */
            minLength?: number;
            /**
             * An integer that specifies the maximum length of a value.
             */
            maxLength?: number;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `array`.
           */
          type: "array";
          /**
           * There are no format keyword options for `array`: only `default` is allowed.
           */
          format?: "default";
          /**
           * The following constraints apply for `array` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?: Array<string> | Array<unknown[]>;
            /**
             * An integer that specifies the minimum length of a value.
             */
            minLength?: number;
            /**
             * An integer that specifies the maximum length of a value.
             */
            maxLength?: number;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `duration`.
           */
          type: "duration";
          /**
           * There are no format keyword options for `duration`: only `default` is allowed.
           */
          format?: "default";
          /**
           * The following constraints are supported for `duration` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?: Array<string>;
            minimum?: string;
            maximum?: string;
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
      | {
          /**
           * A name for this field.
           */
          name: string;
          /**
           * A human-readable title.
           */
          title?: string;
          /**
           * A text description. Markdown is encouraged.
           */
          description?: string;
          /**
           * An example value for the field.
           */
          example?: string;
          /**
           * The type keyword, which `MUST` be a value of `any`.
           */
          type: "any";
          /**
           * The following constraints apply to `any` fields.
           */
          constraints?: {
            /**
             * Indicates whether a property must have a value for each instance.
             */
            required?: boolean;
            /**
             * When `true`, each value for the property `MUST` be unique.
             */
            unique?: boolean;
            enum?: unknown[];
          };
          /**
           * The RDF type for this field.
           */
          rdfType?: string;
        }
    >;
    /**
     * A primary key is a field name or an array of field names, whose values `MUST` uniquely identify each row in the table.
     */
    primaryKey?: Array<string> | string;
    foreignKeys?: Array<{
      fields?: Array<string>;
      reference?: {
        resource: string;
        fields: Array<string>;
      };
    }>;
    /**
     * Values that when encountered in the source, should be considered as `null`, 'not present', or 'blank' values.
     */
    missingValues?: Array<string>;
  };
};

export type format = "csv";

export type mediatype = "text/csv";

export type encoding = "utf-8";

/**
 * This is a JSON object mapping column names to arrays of allowed values.  For example, to filter column `pet` for values `cat` and `dog`, the filter would be `{"pet": ["cat", "dog"]}`. JSON contains characters that are not safe to place in a URL, so it is important to url-encode them.  For this example, the url-encoding is `%7B%22pet%22%3A%20%5B%22cat%22%2C%20%22dog%22%5D%7D`. See https://rosettacode.org/wiki/URL_encoding for how to url-encode a string, or https://www.urlencoder.org/ to try some examples. Multiple columns can be filtered. For example the filter for `pet` being either `cat` or `dog`, AND `size` being either `tiny` or `outrageously small`, would be `{"pet": ["cat", "dog"], "size": ["tiny", "outrageously small"]}`.
 */
export type ParameterfilterQueryParam = string;

/**
 * Order in which to return results. If a single column name is given (e.g. `pet`), results are placed in ascending order of values in that column. To get results in an order that was previously prepared manually in Grist, use the special `manualSort` column name. Multiple columns can be specified, separated by commas (e.g. `pet,age`). For descending order, prefix a column name with a `-` character (e.g. `pet,-age`). To include additional sorting options append them after a colon (e.g. `pet,-age:naturalSort;emptyFirst,owner`). Available options are: `choiceOrder`, `naturalSort`, `emptyFirst`. Without the `sort` parameter, the order of results is unspecified.
 */
export type ParametersortQueryParam = string;

/**
 * Return at most this number of rows.  A value of 0 is equivalent to having no limit.
 */
export type ParameterlimitQueryParam = number;

/**
 * Same as `sort` query parameter.
 */
export type ParametersortHeaderParam = string;

/**
 * Same as `limit` query parameter.
 */
export type ParameterlimitHeaderParam = number;

/**
 * The column id (without the starting `$`) as shown in the column configuration below the label
 */
export type ParametercolIdPathParam = string;

/**
 * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
 */
export type ParametertableIdPathParam = string;

/**
 * A string id (UUID)
 */
export type ParameterdocIdPathParam = string;

/**
 * This can be an integer id, or a string subdomain (e.g. `gristlabs`), or `current` if the org is implied by the domain in the url
 */
export type ParameterorgIdPathParam = number | string;

/**
 * An integer id
 */
export type ParameterworkspaceIdPathParam = number;

/**
 * Set to true to prohibit parsing strings according to the column type.
 */
export type ParameternoparseQueryParam = boolean;

/**
 * Set to true to include the hidden columns (like "manualSort")
 */
export type ParameterhiddenQueryParam = boolean;

/**
 * Format for headers. Labels tend to be more human-friendly while colIds are more normalized.
 */
export type ParameterheaderQueryParam = "colId" | "label";

export type ListOrgsResponse = Orgs;

export type DescribeOrgData = {
  /**
   * This can be an integer id, or a string subdomain (e.g. `gristlabs`), or `current` if the org is implied by the domain in the url
   */
  orgId: number | string;
};

export type DescribeOrgResponse = Org;

export type ModifyOrgData = {
  /**
   * This can be an integer id, or a string subdomain (e.g. `gristlabs`), or `current` if the org is implied by the domain in the url
   */
  orgId: number | string;
  /**
   * the changes to make
   */
  requestBody: OrgParameters;
};

export type ModifyOrgResponse = unknown;

export type ListOrgAccessData = {
  /**
   * This can be an integer id, or a string subdomain (e.g. `gristlabs`), or `current` if the org is implied by the domain in the url
   */
  orgId: number | string;
};

export type ListOrgAccessResponse = OrgAccessRead;

export type ModifyOrgAccessData = {
  /**
   * This can be an integer id, or a string subdomain (e.g. `gristlabs`), or `current` if the org is implied by the domain in the url
   */
  orgId: number | string;
  /**
   * the changes to make
   */
  requestBody: {
    delta: OrgAccessWrite;
  };
};

export type ModifyOrgAccessResponse = unknown;

export type ListWorkspacesData = {
  /**
   * This can be an integer id, or a string subdomain (e.g. `gristlabs`), or `current` if the org is implied by the domain in the url
   */
  orgId: number | string;
};

export type ListWorkspacesResponse = Array<WorkspaceWithDocsAndDomain>;

export type CreateWorkspaceData = {
  /**
   * This can be an integer id, or a string subdomain (e.g. `gristlabs`), or `current` if the org is implied by the domain in the url
   */
  orgId: number | string;
  /**
   * settings for the workspace
   */
  requestBody: WorkspaceParameters;
};

export type CreateWorkspaceResponse = number;

export type DescribeWorkspaceData = {
  /**
   * An integer id
   */
  workspaceId: number;
};

export type DescribeWorkspaceResponse = WorkspaceWithDocsAndOrg;

export type ModifyWorkspaceData = {
  /**
   * the changes to make
   */
  requestBody: WorkspaceParameters;
  /**
   * An integer id
   */
  workspaceId: number;
};

export type ModifyWorkspaceResponse = unknown;

export type DeleteWorkspaceData = {
  /**
   * An integer id
   */
  workspaceId: number;
};

export type DeleteWorkspaceResponse = unknown;

export type CreateDocData = {
  /**
   * settings for the document
   */
  requestBody: DocParameters;
  /**
   * An integer id
   */
  workspaceId: number;
};

export type CreateDocResponse = string;

export type ListWorkspaceAccessData = {
  /**
   * An integer id
   */
  workspaceId: number;
};

export type ListWorkspaceAccessResponse = WorkspaceAccessRead;

export type ModifyWorkspaceAccessData = {
  /**
   * the changes to make
   */
  requestBody: {
    delta: WorkspaceAccessWrite;
  };
  /**
   * An integer id
   */
  workspaceId: number;
};

export type ModifyWorkspaceAccessResponse = unknown;

export type DescribeDocData = {
  /**
   * A string id (UUID)
   */
  docId: string;
};

export type DescribeDocResponse = DocWithWorkspace;

export type ModifyDocData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * the changes to make
   */
  requestBody: DocParameters;
};

export type ModifyDocResponse = unknown;

export type DeleteDocData = {
  /**
   * A string id (UUID)
   */
  docId: string;
};

export type DeleteDocResponse = unknown;

export type MoveDocData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * the target workspace
   */
  requestBody?: {
    workspace: number;
  };
};

export type MoveDocResponse = unknown;

export type ListDocAccessData = {
  /**
   * A string id (UUID)
   */
  docId: string;
};

export type ListDocAccessResponse = WorkspaceAccessRead;

export type ModifyDocAccessData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * the changes to make
   */
  requestBody: {
    delta: WorkspaceAccessWrite;
  };
};

export type ModifyDocAccessResponse = unknown;

export type DownloadDocData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  nohistory?: boolean;
  template?: boolean;
};

export type DownloadDocResponse = Blob | File;

export type DownloadDocXlsxData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * Format for headers. Labels tend to be more human-friendly while colIds are more normalized.
   */
  header?: "colId" | "label";
};

export type DownloadDocXlsxResponse = Blob | File;

export type DownloadDocCsvData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * Format for headers. Labels tend to be more human-friendly while colIds are more normalized.
   */
  header?: "colId" | "label";
  tableId: string;
};

export type DownloadDocCsvResponse = string;

export type DownloadTableSchemaData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * Format for headers. Labels tend to be more human-friendly while colIds are more normalized.
   */
  header?: "colId" | "label";
  tableId: string;
};

export type DownloadTableSchemaResponse = TableSchemaResult;

export type GetTableDataData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * This is a JSON object mapping column names to arrays of allowed values.  For example, to filter column `pet` for values `cat` and `dog`, the filter would be `{"pet": ["cat", "dog"]}`. JSON contains characters that are not safe to place in a URL, so it is important to url-encode them.  For this example, the url-encoding is `%7B%22pet%22%3A%20%5B%22cat%22%2C%20%22dog%22%5D%7D`. See https://rosettacode.org/wiki/URL_encoding for how to url-encode a string, or https://www.urlencoder.org/ to try some examples. Multiple columns can be filtered. For example the filter for `pet` being either `cat` or `dog`, AND `size` being either `tiny` or `outrageously small`, would be `{"pet": ["cat", "dog"], "size": ["tiny", "outrageously small"]}`.
   */
  filter?: string;
  /**
   * Return at most this number of rows.  A value of 0 is equivalent to having no limit.
   */
  limit?: number;
  /**
   * Order in which to return results. If a single column name is given (e.g. `pet`), results are placed in ascending order of values in that column. To get results in an order that was previously prepared manually in Grist, use the special `manualSort` column name. Multiple columns can be specified, separated by commas (e.g. `pet,age`). For descending order, prefix a column name with a `-` character (e.g. `pet,-age`). To include additional sorting options append them after a colon (e.g. `pet,-age:naturalSort;emptyFirst,owner`). Available options are: `choiceOrder`, `naturalSort`, `emptyFirst`. Without the `sort` parameter, the order of results is unspecified.
   */
  sort?: string;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
  /**
   * Same as `limit` query parameter.
   */
  xLimit?: number;
  /**
   * Same as `sort` query parameter.
   */
  xSort?: string;
};

export type GetTableDataResponse = Data;

export type AddRowsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * Set to true to prohibit parsing strings according to the column type.
   */
  noparse?: boolean;
  /**
   * the data to add
   */
  requestBody: DataWithoutId;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
};

export type AddRowsResponse = RowIds;

export type ModifyRowsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * Set to true to prohibit parsing strings according to the column type.
   */
  noparse?: boolean;
  /**
   * the data to change, with ids
   */
  requestBody: Data;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
};

export type ModifyRowsResponse = RowIds;

export type DeleteRowsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * the IDs of rows to remove
   */
  requestBody: RowIds;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
};

export type DeleteRowsResponse = unknown;

export type ListAttachmentsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * This is a JSON object mapping column names to arrays of allowed values.  For example, to filter column `pet` for values `cat` and `dog`, the filter would be `{"pet": ["cat", "dog"]}`. JSON contains characters that are not safe to place in a URL, so it is important to url-encode them.  For this example, the url-encoding is `%7B%22pet%22%3A%20%5B%22cat%22%2C%20%22dog%22%5D%7D`. See https://rosettacode.org/wiki/URL_encoding for how to url-encode a string, or https://www.urlencoder.org/ to try some examples. Multiple columns can be filtered. For example the filter for `pet` being either `cat` or `dog`, AND `size` being either `tiny` or `outrageously small`, would be `{"pet": ["cat", "dog"], "size": ["tiny", "outrageously small"]}`.
   */
  filter?: string;
  /**
   * Return at most this number of rows.  A value of 0 is equivalent to having no limit.
   */
  limit?: number;
  /**
   * Order in which to return results. If a single column name is given (e.g. `pet`), results are placed in ascending order of values in that column. To get results in an order that was previously prepared manually in Grist, use the special `manualSort` column name. Multiple columns can be specified, separated by commas (e.g. `pet,age`). For descending order, prefix a column name with a `-` character (e.g. `pet,-age`). To include additional sorting options append them after a colon (e.g. `pet,-age:naturalSort;emptyFirst,owner`). Available options are: `choiceOrder`, `naturalSort`, `emptyFirst`. Without the `sort` parameter, the order of results is unspecified.
   */
  sort?: string;
  /**
   * Same as `limit` query parameter.
   */
  xLimit?: number;
  /**
   * Same as `sort` query parameter.
   */
  xSort?: string;
};

export type ListAttachmentsResponse = AttachmentMetadataList;

export type UploadAttachmentsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * the files to add to the doc
   */
  formData: AttachmentUpload;
};

export type UploadAttachmentsResponse = RowIds;

export type GetAttachmentMetadataData = {
  attachmentId: AttachmentId;
  /**
   * A string id (UUID)
   */
  docId: string;
};

export type GetAttachmentMetadataResponse = AttachmentMetadata;

export type DownloadAttachmentData = {
  attachmentId: AttachmentId;
  /**
   * A string id (UUID)
   */
  docId: string;
};

export type DownloadAttachmentResponse = unknown;

export type ListRecordsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * This is a JSON object mapping column names to arrays of allowed values.  For example, to filter column `pet` for values `cat` and `dog`, the filter would be `{"pet": ["cat", "dog"]}`. JSON contains characters that are not safe to place in a URL, so it is important to url-encode them.  For this example, the url-encoding is `%7B%22pet%22%3A%20%5B%22cat%22%2C%20%22dog%22%5D%7D`. See https://rosettacode.org/wiki/URL_encoding for how to url-encode a string, or https://www.urlencoder.org/ to try some examples. Multiple columns can be filtered. For example the filter for `pet` being either `cat` or `dog`, AND `size` being either `tiny` or `outrageously small`, would be `{"pet": ["cat", "dog"], "size": ["tiny", "outrageously small"]}`.
   */
  filter?: string;
  /**
   * Set to true to include the hidden columns (like "manualSort")
   */
  hidden?: boolean;
  /**
   * Return at most this number of rows.  A value of 0 is equivalent to having no limit.
   */
  limit?: number;
  /**
   * Order in which to return results. If a single column name is given (e.g. `pet`), results are placed in ascending order of values in that column. To get results in an order that was previously prepared manually in Grist, use the special `manualSort` column name. Multiple columns can be specified, separated by commas (e.g. `pet,age`). For descending order, prefix a column name with a `-` character (e.g. `pet,-age`). To include additional sorting options append them after a colon (e.g. `pet,-age:naturalSort;emptyFirst,owner`). Available options are: `choiceOrder`, `naturalSort`, `emptyFirst`. Without the `sort` parameter, the order of results is unspecified.
   */
  sort?: string;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
  /**
   * Same as `limit` query parameter.
   */
  xLimit?: number;
  /**
   * Same as `sort` query parameter.
   */
  xSort?: string;
};

export type ListRecordsResponse = RecordsList;

export type AddRecordsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * Set to true to prohibit parsing strings according to the column type.
   */
  noparse?: boolean;
  /**
   * the records to add
   */
  requestBody: RecordsWithoutId;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
};

export type AddRecordsResponse = RecordsWithoutFields;

export type ModifyRecordsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * Set to true to prohibit parsing strings according to the column type.
   */
  noparse?: boolean;
  /**
   * the records to change, with ids
   */
  requestBody: RecordsList;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
};

export type ModifyRecordsResponse = unknown;

export type ReplaceRecordsData = {
  allowEmptyRequire?: boolean;
  /**
   * A string id (UUID)
   */
  docId: string;
  noadd?: boolean;
  /**
   * Set to true to prohibit parsing strings according to the column type.
   */
  noparse?: boolean;
  noupdate?: boolean;
  onmany?: "first" | "none" | "all";
  /**
   * The records to add or update. Instead of an id, a `require` object is provided, with the same structure as `fields`. If no query parameter options are set, then the operation is as follows. First, we check if a record exists matching the values specified for columns in `require`. If so, we update it by setting the values specified for columns in `fields`. If not, we create a new record with a combination of the values in `require` and `fields`, with `fields` taking priority if the same column is specified in both. The query parameters allow for variations on this behavior.
   *
   */
  requestBody: RecordsWithRequire;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
};

export type ReplaceRecordsResponse = unknown;

export type ListTablesData = {
  /**
   * A string id (UUID)
   */
  docId: string;
};

export type ListTablesResponse = TablesList;

export type AddTablesData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * the tables to add
   */
  requestBody: CreateTables;
};

export type AddTablesResponse = TablesWithoutFields;

export type ModifyTablesData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * the tables to change, with ids
   */
  requestBody: TablesList;
};

export type ModifyTablesResponse = unknown;

export type ListColumnsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * Set to true to include the hidden columns (like "manualSort")
   */
  hidden?: boolean;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
};

export type ListColumnsResponse = ColumnsList;

export type AddColumnsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * the columns to add
   */
  requestBody: CreateColumns;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
};

export type AddColumnsResponse = ColumnsWithoutFields;

export type ModifyColumnsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * the columns to change, with ids
   */
  requestBody: UpdateColumns;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
};

export type ModifyColumnsResponse = unknown;

export type ReplaceColumnsData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  noadd?: boolean;
  noupdate?: boolean;
  replaceall?: boolean;
  /**
   * The columns to add or update. We check whether the specified column ID exists: if so, the column is updated with the provided data, otherwise a new column is created.
   * Also note that some query parameters alter this behavior.
   *
   */
  requestBody: UpdateColumns;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
};

export type ReplaceColumnsResponse = unknown;

export type DeleteColumnData = {
  /**
   * The column id (without the starting `$`) as shown in the column configuration below the label
   */
  colId: string;
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * normalized table name (see `TABLE ID` in Raw Data) or numeric row ID in `_grist_Tables`
   */
  tableId: string;
};

export type DeleteColumnResponse = unknown;

export type GetDocsByDocIdWebhooksData = {
  /**
   * A string id (UUID)
   */
  docId: string;
};

export type GetDocsByDocIdWebhooksResponse = {
  webhooks: Webhooks;
};

export type PostDocsByDocIdWebhooksData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * an array of webhook settings
   */
  requestBody?: {
    webhooks: Array<{
      fields: WebhookPartialFields;
    }>;
  };
};

export type PostDocsByDocIdWebhooksResponse = {
  webhooks: Array<WebhookId>;
};

export type PatchDocsByDocIdWebhooksByWebhookIdData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * the changes to make
   */
  requestBody?: WebhookPartialFields;
  webhookId: string;
};

export type PatchDocsByDocIdWebhooksByWebhookIdResponse = unknown;

export type DeleteDocsByDocIdWebhooksByWebhookIdData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  webhookId: string;
};

export type DeleteDocsByDocIdWebhooksByWebhookIdResponse = {
  success: boolean;
};

export type DeleteDocsByDocIdWebhooksQueueData = {
  /**
   * A string id (UUID)
   */
  docId: string;
};

export type DeleteDocsByDocIdWebhooksQueueResponse = unknown;

export type GetDocsByDocIdSqlData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  q?: string;
};

export type GetDocsByDocIdSqlResponse = SqlResultSet;

export type PostDocsByDocIdSqlData = {
  /**
   * A string id (UUID)
   */
  docId: string;
  /**
   * Query options
   */
  requestBody?: {
    /**
     * The SQL query to run. Must be a single SELECT statement, with no trailing semicolon. WITH clauses are permitted. All Grist documents are currently SQLite databases, and the SQL query is interpreted and run by SQLite, with various defensive measures. Statements that would modify the database are not supported.
     */
    sql: string;
    /**
     * Parameters for the query.
     */
    args?: Array<number | string>;
    /**
     * Timeout after which operations on the document will be interrupted. Specified in milliseconds. Defaults to 1000 (1 second). This default is controlled by an optional environment variable read by the Grist app, GRIST_SQL_TIMEOUT_MSEC. The default cannot be exceeded, only reduced.
     */
    timeout?: number;
  };
};

export type PostDocsByDocIdSqlResponse = SqlResultSet;

export type $OpenApiTs = {
  "/orgs": {
    get: {
      res: {
        /**
         * An array of organizations
         */
        200: Orgs;
      };
    };
  };
  "/orgs/{orgId}": {
    get: {
      req: DescribeOrgData;
      res: {
        /**
         * An organization
         */
        200: Org;
      };
    };
    patch: {
      req: ModifyOrgData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
  };
  "/orgs/{orgId}/access": {
    get: {
      req: ListOrgAccessData;
      res: {
        /**
         * Users with access to org
         */
        200: OrgAccessRead;
      };
    };
    patch: {
      req: ModifyOrgAccessData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
  };
  "/orgs/{orgId}/workspaces": {
    get: {
      req: ListWorkspacesData;
      res: {
        /**
         * An org's workspaces and documents
         */
        200: Array<WorkspaceWithDocsAndDomain>;
      };
    };
    post: {
      req: CreateWorkspaceData;
      res: {
        /**
         * The workspace id
         */
        200: number;
      };
    };
  };
  "/workspaces/{workspaceId}": {
    get: {
      req: DescribeWorkspaceData;
      res: {
        /**
         * A workspace
         */
        200: WorkspaceWithDocsAndOrg;
      };
    };
    patch: {
      req: ModifyWorkspaceData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
    delete: {
      req: DeleteWorkspaceData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
  };
  "/workspaces/{workspaceId}/docs": {
    post: {
      req: CreateDocData;
      res: {
        /**
         * The document id
         */
        200: string;
      };
    };
  };
  "/workspaces/{workspaceId}/access": {
    get: {
      req: ListWorkspaceAccessData;
      res: {
        /**
         * Users with access to workspace
         */
        200: WorkspaceAccessRead;
      };
    };
    patch: {
      req: ModifyWorkspaceAccessData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
  };
  "/docs/{docId}": {
    get: {
      req: DescribeDocData;
      res: {
        /**
         * A document's metadata
         */
        200: DocWithWorkspace;
      };
    };
    patch: {
      req: ModifyDocData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
    delete: {
      req: DeleteDocData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
  };
  "/docs/{docId}/move": {
    patch: {
      req: MoveDocData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
  };
  "/docs/{docId}/access": {
    get: {
      req: ListDocAccessData;
      res: {
        /**
         * Users with access to document
         */
        200: WorkspaceAccessRead;
      };
    };
    patch: {
      req: ModifyDocAccessData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
  };
  "/docs/{docId}/download": {
    get: {
      req: DownloadDocData;
      res: {
        /**
         * A document's content in Sqlite form
         */
        200: Blob | File;
      };
    };
  };
  "/docs/{docId}/download/xlsx": {
    get: {
      req: DownloadDocXlsxData;
      res: {
        /**
         * A document's content in Excel form
         */
        200: Blob | File;
      };
    };
  };
  "/docs/{docId}/download/csv": {
    get: {
      req: DownloadDocCsvData;
      res: {
        /**
         * A table's content in CSV form
         */
        200: string;
      };
    };
  };
  "/docs/{docId}/download/table-schema": {
    get: {
      req: DownloadTableSchemaData;
      res: {
        /**
         * A table's table-schema in JSON format.
         */
        200: TableSchemaResult;
      };
    };
  };
  "/docs/{docId}/tables/{tableId}/data": {
    get: {
      req: GetTableDataData;
      res: {
        /**
         * Cells from the table
         */
        200: Data;
      };
    };
    post: {
      req: AddRowsData;
      res: {
        /**
         * IDs of rows added
         */
        200: RowIds;
      };
    };
    patch: {
      req: ModifyRowsData;
      res: {
        /**
         * IDs of rows modified
         */
        200: RowIds;
      };
    };
  };
  "/docs/{docId}/tables/{tableId}/data/delete": {
    post: {
      req: DeleteRowsData;
      res: {
        /**
         * Nothing returned
         */
        200: unknown;
      };
    };
  };
  "/docs/{docId}/attachments": {
    get: {
      req: ListAttachmentsData;
      res: {
        /**
         * List of attachment metadata records. Note that the list may temporarily include records for attachments that are stored in the document but not referenced by any Attachments type cell.
         */
        200: AttachmentMetadataList;
      };
    };
    post: {
      req: UploadAttachmentsData;
      res: {
        /**
         * IDs of attachments added, one per file.
         */
        200: RowIds;
      };
    };
  };
  "/docs/{docId}/attachments/{attachmentId}": {
    get: {
      req: GetAttachmentMetadataData;
      res: {
        /**
         * Attachment metadata
         */
        200: AttachmentMetadata;
      };
    };
  };
  "/docs/{docId}/attachments/{attachmentId}/download": {
    get: {
      req: DownloadAttachmentData;
      res: {
        /**
         * Attachment contents, with suitable Content-Type.
         */
        200: unknown;
      };
    };
  };
  "/docs/{docId}/tables/{tableId}/records": {
    get: {
      req: ListRecordsData;
      res: {
        /**
         * Records from the table
         */
        200: RecordsList;
      };
    };
    post: {
      req: AddRecordsData;
      res: {
        /**
         * IDs of records added
         */
        200: RecordsWithoutFields;
      };
    };
    patch: {
      req: ModifyRecordsData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
    put: {
      req: ReplaceRecordsData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
  };
  "/docs/{docId}/tables": {
    get: {
      req: ListTablesData;
      res: {
        /**
         * The tables in a document
         */
        200: TablesList;
      };
    };
    post: {
      req: AddTablesData;
      res: {
        /**
         * The table created
         */
        200: TablesWithoutFields;
      };
    };
    patch: {
      req: ModifyTablesData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
  };
  "/docs/{docId}/tables/{tableId}/columns": {
    get: {
      req: ListColumnsData;
      res: {
        /**
         * The columns in a table
         */
        200: ColumnsList;
      };
    };
    post: {
      req: AddColumnsData;
      res: {
        /**
         * The columns created
         */
        200: ColumnsWithoutFields;
      };
    };
    patch: {
      req: ModifyColumnsData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
    put: {
      req: ReplaceColumnsData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
  };
  "/docs/{docId}/tables/{tableId}/columns/{colId}": {
    delete: {
      req: DeleteColumnData;
      res: {
        /**
         * Success
         */
        200: unknown;
      };
    };
  };
  "/docs/{docId}/webhooks": {
    get: {
      req: GetDocsByDocIdWebhooksData;
      res: {
        /**
         * A list of webhooks.
         */
        200: {
          webhooks: Webhooks;
        };
      };
    };
    post: {
      req: PostDocsByDocIdWebhooksData;
      res: {
        /**
         * Success
         */
        200: {
          webhooks: Array<WebhookId>;
        };
      };
    };
  };
  "/docs/{docId}/webhooks/{webhookId}": {
    patch: {
      req: PatchDocsByDocIdWebhooksByWebhookIdData;
      res: {
        /**
         * Success.
         */
        200: unknown;
      };
    };
    delete: {
      req: DeleteDocsByDocIdWebhooksByWebhookIdData;
      res: {
        /**
         * Success.
         */
        200: {
          success: boolean;
        };
      };
    };
  };
  "/docs/{docId}/webhooks/queue": {
    delete: {
      req: DeleteDocsByDocIdWebhooksQueueData;
      res: {
        /**
         * Success.
         */
        200: unknown;
      };
    };
  };
  "/docs/{docId}/sql": {
    get: {
      req: GetDocsByDocIdSqlData;
      res: {
        /**
         * The result set for the query.
         */
        200: SqlResultSet;
      };
    };
    post: {
      req: PostDocsByDocIdSqlData;
      res: {
        /**
         * The result set for the query.
         */
        200: SqlResultSet;
      };
    };
  };
};
